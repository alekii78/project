import asyncio
import json
import pandas as pd
import websockets
from config import DERIV_TOKEN, DERIV_APP_ID

TRADE_INTERVAL = 1  # minutes
STAKE = 1  # USD
SAFE_MIN_DURATION = 1  # minimum duration to trade in minutes

# Use synthetic indices that allow 1-minute contracts in demo
DERIV_SYMBOLS = ["R_100", "R_25"]  

# -------------------- Helper functions --------------------

async def get_valid_symbol():
    """Return the first symbol with available contracts."""
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={DERIV_APP_ID}"
    async with websockets.connect(uri) as ws:
        await ws.send(json.dumps({"authorize": DERIV_TOKEN}))
        await ws.recv()

        await ws.send(json.dumps({"active_symbols": "brief", "product_type": "synthetic_index"}))
        resp = await ws.recv()
        data = json.loads(resp)
        available = [s["symbol"] for s in data.get("active_symbols", [])]
        for sym in DERIV_SYMBOLS:
            if sym in available:
                return sym
    return DERIV_SYMBOLS[0]  # fallback if none found

async def get_available_durations(symbol):
    """Return all valid durations for a symbol in minutes."""
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={DERIV_APP_ID}"
    async with websockets.connect(uri) as ws:
        await ws.send(json.dumps({"authorize": DERIV_TOKEN}))
        await ws.recv()

        await ws.send(json.dumps({"contracts_for": symbol}))
        resp = await ws.recv()
        data = json.loads(resp)

        durations = []
        contracts = data.get("contracts_for", {}).get("available", [])
        for c in contracts:
            underlying = c.get("underlying", "")
            if underlying in DERIV_SYMBOLS:
                min_dur = int(c.get("min_contract_duration", 1))
                max_dur = int(c.get("max_contract_duration", min_dur))
                durations.extend(range(min_dur, max_dur + 1))

        if not durations:
            print(f"‚ö†Ô∏è No tradeable durations found for {symbol}")
        else:
            print(f"üïí Tradeable durations for {symbol}: {sorted(durations)}")

        return sorted(list(set(durations)))

async def get_deriv_candles(symbol, n=5, granularity=1):
    """Fetch the latest n candles for a symbol."""
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={DERIV_APP_ID}"
    async with websockets.connect(uri) as ws:
        await ws.send(json.dumps({"authorize": DERIV_TOKEN}))
        await ws.recv()

        request = {
            "ticks_history": symbol,
            "end": "latest",
            "count": n,
            "granularity": granularity * 60,  # 1-minute candles
            "style": "candles"
        }
        await ws.send(json.dumps(request))
        resp = await ws.recv()
        data = json.loads(resp)

        candles = data.get("candles")
        if not candles:
            return pd.DataFrame()

        df = pd.DataFrame(candles)
        df.rename(columns={'open':'Open','high':'High','low':'Low','close':'Close'}, inplace=True)
        for col in ['Open','High','Low','Close']:
            df[col] = df[col].astype(float)
        return df
import random
def signal_generator(df):
    """Generate BUY/SELL signals based on last two candles."""
    if len(df) < 2:
        return 0
    open_ = df.Open.iloc[-1]
    close_ = df.Close.iloc[-1]
    prev_open = df.Open.iloc[-2]
    prev_close = df.Close.iloc[-2]
    if open_ > close_ and prev_open < prev_close and close_ < prev_open and open_ >= prev_close:
        return 1  # SELL
    elif open_ < close_ and prev_open > prev_close and close_ > prev_open and open_ <= prev_close:
        return 2  # BUY
    if df.Close.iloc[-1] > df.Close.iloc[-2]:
        return 2  # BUY
    elif df.Close.iloc[-1] < df.Close.iloc[-2]:
        return 1  # SELL
    return random.choice([1, 2])
    return 0

async def trade_on_deriv(symbol, signal, stake=STAKE):
    """Attempt to trade on Deriv using available durations."""
    durations = await get_available_durations(symbol)
    if not durations:
        print(f"‚ö†Ô∏è Skipping {symbol}, no valid durations")
        return False

    for duration in durations:
        try:
            uri = f"wss://ws.derivws.com/websockets/v3?app_id={DERIV_APP_ID}"
            async with websockets.connect(uri) as ws:
                await ws.send(json.dumps({"authorize": DERIV_TOKEN}))
                await ws.recv()

                contract_type = "CALL" if signal == 2 else "PUT"
                proposal = {
                    "proposal": 1,
                    "amount": stake,
                    "basis": "stake",
                    "contract_type": contract_type,
                    "currency": "USD",
                    "duration": duration,
                    "duration_unit": "m",
                    "symbol": symbol
                }

                await ws.send(json.dumps(proposal))
                proposal_resp = await ws.recv()
                proposal_data = json.loads(proposal_resp)

                if "error" in proposal_data:
                    print(f"‚ùå Proposal failed for {symbol} ({duration}m): {proposal_data['error']['message']}")
                    continue

                contract_id = proposal_data["proposal"]["id"]
                await ws.send(json.dumps({"buy": contract_id, "price": stake}))
                buy_resp = await ws.recv()
                print(f"üí∞ Trade executed on {symbol} for duration {duration}m:", buy_resp)
                print(f"üìà Placing {signal} trade for {symbol} ...")
                response = await websockets.send(json.dumps(proposal))

                return True
        except Exception as e:
            print(f"‚ö†Ô∏è Error trading {symbol} ({duration}m):", e)
            continue

    print(f"‚ùå All durations failed for {symbol}.")
    return False

# -------------------- Main trading loop --------------------

async def trading_loop():
    while True:
        symbol = await get_valid_symbol()
        print(f"‚úÖ Using symbol: {symbol}")
        df = await get_deriv_candles(symbol, granularity=1)  # 1-minute candles
        print("Latest candles:\n", df.tail())
        signal = signal_generator(df)
        print("Signal:", "SELL" if signal == 1 else "BUY" if signal == 2 else "NONE")

        # if signal in (1, 2):
        #     success = await trade_on_deriv(symbol, signal)
        #     if not success:
        #         # fallback to next symbol
        #         for next_sym in DERIV_SYMBOLS:
        #             if next_sym != symbol:
        #                 print(f"‚ö° Trying fallback symbol: {next_sym}")
        #                 df_next = await get_deriv_candles(next_sym, granularity=1)
        #                 sig_next = signal_generator(df_next)
        #                 if sig_next in (1, 2):
        #                     await trade_on_deriv(next_sym, sig_next)
        #                     break
        # else:
        #     print("‚ö™ No trade this round.")
           # Always trade
         # Always trade
    success = await trade_on_deriv(symbol, signal)
    if not success:
        # fallback to next symbol if main fails
        for next_sym in DERIV_SYMBOLS:
            if next_sym != symbol:
                print(f"‚ö° Trying fallback symbol: {next_sym}")
                df_next = await get_deriv_candles(next_sym, granularity=1)
                sig_next = signal_generator(df_next)
                await trade_on_deriv(next_sym, sig_next)
                break

            print(f"‚è≥ Waiting {TRADE_INTERVAL} minutes before next trade...\n")
            await asyncio.sleep(TRADE_INTERVAL * 60)

if __name__ == "__main__":
    asyncio.run(trading_loop())
